#[cfg(any(
    feature = "gb18030",
    feature = "euc-jp",
    feature = "iso-2022-jp",
    feature = "euc-kr",
    feature = "big5",
    feature = "shift-jis",
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
use std::collections::BTreeMap;
#[cfg(any(
    feature = "gb18030",
    feature = "euc-jp",
    feature = "iso-2022-jp",
    feature = "euc-kr",
    feature = "big5",
    feature = "shift-jis",
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
use std::fmt::Write;
#[cfg(any(
    feature = "gb18030",
    feature = "euc-jp",
    feature = "iso-2022-jp",
    feature = "euc-kr",
    feature = "big5",
    feature = "shift-jis",
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
use std::path::Path;

fn main() {
    // GB18030 (feature-gated)
    #[cfg(feature = "gb18030")]
    build_gb18030();

    // Japanese encodings - JIS X 0208 table (shared by EUC-JP, ISO-2022-JP, and Shift_JIS)
    #[cfg(any(feature = "euc-jp", feature = "iso-2022-jp", feature = "shift-jis"))]
    build_jis0208_tables();

    // JIS X 0212 table (only EUC-JP)
    #[cfg(feature = "euc-jp")]
    build_jis0212_tables();

    // Korean encoding - EUC-KR
    #[cfg(feature = "euc-kr")]
    build_euckr_tables();

    // Traditional Chinese - Big5
    #[cfg(feature = "big5")]
    build_big5_tables();

    // Legacy codepages (granular feature-gated)
    #[cfg(any(
        feature = "codepages-iso8859",
        feature = "codepages-windows",
        feature = "codepages-dos",
        feature = "codepages-apple",
        feature = "codepages-misc",
    ))]
    build_codepages();
}

#[cfg(feature = "gb18030")]
fn build_gb18030() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("gb18030_tables.rs");

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n");
    output.push_str("// GB18030 encoding tables\n\n");

    // Parse WHATWG index-gb18030.txt for 2-byte mappings (preferred, includes Euro etc.)
    let index_path = Path::new("data/index-gb18030.txt");
    if index_path.exists() {
        generate_gbk_tables_from_whatwg(index_path, &mut output);
    } else {
        // Fallback to CP936.TXT
        let cp936_path = Path::new("data/mappings/windows/CP936.TXT");
        if cp936_path.exists() {
            generate_gbk_tables_from_cp936(cp936_path, &mut output);
        } else {
            output.push_str("// WARNING: No 2-byte mapping files found\n");
            output.push_str("pub(crate) static GBK_DECODE_2BYTE: &[(u16, char)] = &[];\n");
            output.push_str("pub(crate) static GBK_ENCODE: &[(char, u16)] = &[];\n\n");
        }
    }

    // Parse index-gb18030-ranges.txt for 4-byte algorithmic ranges
    let ranges_path = Path::new("data/index-gb18030-ranges.txt");
    if ranges_path.exists() {
        generate_gb18030_ranges(ranges_path, &mut output);
    } else {
        output.push_str("// WARNING: gb18030-ranges.txt not found\n");
        output.push_str("pub(crate) static GB18030_RANGES: &[(u32, u32)] = &[];\n");
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/index-gb18030.txt");
    println!("cargo:rerun-if-changed=data/mappings/windows/CP936.TXT");
    println!("cargo:rerun-if-changed=data/index-gb18030-ranges.txt");
}

#[cfg(feature = "gb18030")]
/// Generate GBK tables from WHATWG index format.
/// Index format: pointer -> codepoint, where bytes are calculated from pointer.
fn generate_gbk_tables_from_whatwg(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode_2byte: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Format: pointer\tcodepoint\tname (tab or space separated)
        let parts: Vec<&str> = line
            .split(|c| c == '\t' || c == ' ')
            .filter(|s| !s.is_empty())
            .collect();

        if parts.len() < 2 {
            continue;
        }

        let pointer: u32 = match parts[0].parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let cp_str = parts[1].trim();
        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        // Convert WHATWG pointer to actual bytes
        // lead = pointer / 190 + 0x81
        // offset = pointer % 190
        // trail = offset + 0x40 if offset < 0x3F else offset + 0x41
        let lead = (pointer / 190 + 0x81) as u8;
        let offset = pointer % 190;
        let trail = if offset < 0x3F {
            (offset + 0x40) as u8
        } else {
            (offset + 0x41) as u8
        };

        let bytes = ((lead as u16) << 8) | (trail as u16);

        if let Some(c) = char::from_u32(codepoint) {
            decode_2byte.insert(bytes, c);
        }
    }

    // Generate decode table (sorted by byte value for binary search)
    writeln!(output, "/// GBK 2-byte decode table: (bytes, char)").unwrap();
    writeln!(
        output,
        "pub(crate) static GBK_DECODE_2BYTE: &[(u16, char)] = &["
    )
    .unwrap();
    for (&bytes, &ch) in &decode_2byte {
        writeln!(output, "    (0x{:04X}, '\\u{{{:04X}}}'),", bytes, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();

    // Generate encode table (sorted by char for binary search)
    let mut encode: BTreeMap<char, u16> = BTreeMap::new();
    for (&bytes, &ch) in &decode_2byte {
        encode.entry(ch).or_insert(bytes);
    }

    writeln!(output, "/// GBK 2-byte encode table: (char, bytes)").unwrap();
    writeln!(output, "pub(crate) static GBK_ENCODE: &[(char, u16)] = &[").unwrap();
    for (&ch, &bytes) in &encode {
        writeln!(output, "    ('\\u{{{:04X}}}', 0x{:04X}),", ch as u32, bytes).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

#[cfg(feature = "gb18030")]
fn generate_gbk_tables_from_cp936(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode_2byte: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line
            .split(|c| c == '\t' || c == ' ')
            .filter(|s| !s.is_empty())
            .collect();

        if parts.len() < 2 {
            continue;
        }

        let byte_str = parts[0].trim();
        let byte_val = if byte_str.starts_with("0x") || byte_str.starts_with("0X") {
            match u32::from_str_radix(&byte_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        // Only interested in 2-byte sequences (0x8140-0xFEFE range)
        if byte_val <= 0xFF || byte_val > 0xFFFF {
            continue;
        }

        let cp_str = parts[1].trim();
        if cp_str.is_empty() || cp_str.starts_with('#') {
            continue;
        }

        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        if let Some(c) = char::from_u32(codepoint) {
            decode_2byte.insert(byte_val as u16, c);
        }
    }

    // Generate decode table (sorted by byte value for binary search)
    writeln!(output, "/// GBK 2-byte decode table: (bytes, char)").unwrap();
    writeln!(
        output,
        "pub(crate) static GBK_DECODE_2BYTE: &[(u16, char)] = &["
    )
    .unwrap();
    for (&bytes, &ch) in &decode_2byte {
        writeln!(output, "    (0x{:04X}, '\\u{{{:04X}}}'),", bytes, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();

    // Generate encode table (sorted by char for binary search)
    // Build reverse mapping, keeping first occurrence
    let mut encode: BTreeMap<char, u16> = BTreeMap::new();
    for (&bytes, &ch) in &decode_2byte {
        encode.entry(ch).or_insert(bytes);
    }

    writeln!(output, "/// GBK 2-byte encode table: (char, bytes)").unwrap();
    writeln!(output, "pub(crate) static GBK_ENCODE: &[(char, u16)] = &[").unwrap();
    for (&ch, &bytes) in &encode {
        writeln!(output, "    ('\\u{{{:04X}}}', 0x{:04X}),", ch as u32, bytes).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

#[cfg(feature = "gb18030")]
fn generate_gb18030_ranges(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut ranges: Vec<(u32, u32)> = Vec::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() < 2 {
            continue;
        }

        let pointer: u32 = match parts[0].parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let codepoint_str = parts[1].trim();
        let codepoint = if codepoint_str.starts_with("0x") || codepoint_str.starts_with("0X") {
            match u32::from_str_radix(&codepoint_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        ranges.push((pointer, codepoint));
    }

    writeln!(
        output,
        "/// GB18030 4-byte range table: (pointer, codepoint)"
    )
    .unwrap();
    writeln!(
        output,
        "/// Between consecutive entries, codepoints are sequential."
    )
    .unwrap();
    writeln!(
        output,
        "pub(crate) static GB18030_RANGES: &[(u32, u32)] = &["
    )
    .unwrap();
    for (pointer, codepoint) in &ranges {
        writeln!(output, "    ({}, 0x{:04X}),", pointer, codepoint).unwrap();
    }
    writeln!(output, "];").unwrap();
}

// ============================================================================
// JIS tables for EUC-JP, ISO-2022-JP, and Shift_JIS
// ============================================================================

#[cfg(any(feature = "euc-jp", feature = "iso-2022-jp", feature = "shift-jis"))]
fn build_jis0208_tables() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("jis0208_tables.rs");

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n");
    output.push_str("// JIS X 0208 encoding tables\n\n");

    // JIS X 0208 - used by both EUC-JP and ISO-2022-JP
    let jis0208_path = Path::new("data/index-jis0208.txt");
    if jis0208_path.exists() {
        generate_jis0208_tables(jis0208_path, &mut output);
    } else {
        output.push_str("// WARNING: index-jis0208.txt not found\n");
        output.push_str("pub(crate) static JIS0208_DECODE: &[(u16, char)] = &[];\n");
        output.push_str("pub(crate) static JIS0208_ENCODE: &[(char, u16)] = &[];\n\n");
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/index-jis0208.txt");
}

#[cfg(feature = "euc-jp")]
fn build_jis0212_tables() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("jis0212_tables.rs");

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n");
    output.push_str("// JIS X 0212 encoding tables\n\n");

    // JIS X 0212 - only used by EUC-JP (3-byte sequences)
    let jis0212_path = Path::new("data/index-jis0212.txt");
    if jis0212_path.exists() {
        generate_jis0212_table(jis0212_path, &mut output);
    } else {
        output.push_str("// WARNING: index-jis0212.txt not found\n");
        output.push_str("pub(crate) static JIS0212_DECODE: &[(u16, char)] = &[];\n");
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/index-jis0212.txt");
}

#[cfg(any(feature = "euc-jp", feature = "iso-2022-jp", feature = "shift-jis"))]
fn generate_jis0208_tables(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Format: pointer\t0xCodepoint\tCharacter (Name)
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() < 2 {
            continue;
        }

        let pointer: u16 = match parts[0].trim().parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let cp_str = parts[1].trim();
        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        if let Some(c) = char::from_u32(codepoint) {
            decode.insert(pointer, c);
        }
    }

    // Generate decode table (sorted by pointer for binary search)
    writeln!(output, "/// JIS X 0208 decode table: (pointer, char)").unwrap();
    writeln!(
        output,
        "pub(crate) static JIS0208_DECODE: &[(u16, char)] = &["
    )
    .unwrap();
    for (&pointer, &ch) in &decode {
        writeln!(output, "    ({}, '\\u{{{:04X}}}'),", pointer, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();

    // Generate encode table (sorted by char for binary search)
    let mut encode: BTreeMap<char, u16> = BTreeMap::new();
    for (&pointer, &ch) in &decode {
        encode.entry(ch).or_insert(pointer);
    }

    writeln!(output, "/// JIS X 0208 encode table: (char, pointer)").unwrap();
    writeln!(
        output,
        "pub(crate) static JIS0208_ENCODE: &[(char, u16)] = &["
    )
    .unwrap();
    for (&ch, &pointer) in &encode {
        writeln!(output, "    ('\\u{{{:04X}}}', {}),", ch as u32, pointer).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

#[cfg(feature = "euc-jp")]
fn generate_jis0212_table(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Format: pointer\t0xCodepoint\tCharacter (Name)
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() < 2 {
            continue;
        }

        let pointer: u16 = match parts[0].trim().parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let cp_str = parts[1].trim();
        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        if let Some(c) = char::from_u32(codepoint) {
            decode.insert(pointer, c);
        }
    }

    // Generate decode table only (JIS X 0212 is rarely used for encoding)
    writeln!(output, "/// JIS X 0212 decode table: (pointer, char)").unwrap();
    writeln!(
        output,
        "pub(crate) static JIS0212_DECODE: &[(u16, char)] = &["
    )
    .unwrap();
    for (&pointer, &ch) in &decode {
        writeln!(output, "    ({}, '\\u{{{:04X}}}'),", pointer, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

// ============================================================================
// EUC-KR tables for Korean
// ============================================================================

#[cfg(feature = "euc-kr")]
fn build_euckr_tables() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("euckr_tables.rs");

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n");
    output.push_str("// EUC-KR encoding tables\n\n");

    let index_path = Path::new("data/index-euc-kr.txt");
    if index_path.exists() {
        generate_euckr_tables(index_path, &mut output);
    } else {
        output.push_str("// WARNING: index-euc-kr.txt not found\n");
        output.push_str("pub(crate) static EUCKR_DECODE: &[(u16, char)] = &[];\n");
        output.push_str("pub(crate) static EUCKR_ENCODE: &[(char, u16)] = &[];\n\n");
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/index-euc-kr.txt");
}

#[cfg(feature = "euc-kr")]
fn generate_euckr_tables(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Format: pointer\t0xCodepoint\tCharacter (Name)
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() < 2 {
            continue;
        }

        let pointer: u16 = match parts[0].trim().parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let cp_str = parts[1].trim();
        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        if let Some(c) = char::from_u32(codepoint) {
            decode.insert(pointer, c);
        }
    }

    // Generate decode table (sorted by pointer for binary search)
    writeln!(output, "/// EUC-KR decode table: (pointer, char)").unwrap();
    writeln!(
        output,
        "pub(crate) static EUCKR_DECODE: &[(u16, char)] = &["
    )
    .unwrap();
    for (&pointer, &ch) in &decode {
        writeln!(output, "    ({}, '\\u{{{:04X}}}'),", pointer, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();

    // Generate encode table (sorted by char for binary search)
    let mut encode: BTreeMap<char, u16> = BTreeMap::new();
    for (&pointer, &ch) in &decode {
        encode.entry(ch).or_insert(pointer);
    }

    writeln!(output, "/// EUC-KR encode table: (char, pointer)").unwrap();
    writeln!(
        output,
        "pub(crate) static EUCKR_ENCODE: &[(char, u16)] = &["
    )
    .unwrap();
    for (&ch, &pointer) in &encode {
        writeln!(output, "    ('\\u{{{:04X}}}', {}),", ch as u32, pointer).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

// ============================================================================
// Big5 tables for Traditional Chinese
// ============================================================================

#[cfg(feature = "big5")]
fn build_big5_tables() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = std::path::Path::new(&out_dir).join("big5_tables.rs");

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n");
    output.push_str("// Big5 encoding tables\n\n");

    let index_path = Path::new("data/index-big5.txt");
    if index_path.exists() {
        generate_big5_tables(index_path, &mut output);
    } else {
        output.push_str("// WARNING: index-big5.txt not found\n");
        output.push_str("pub(crate) static BIG5_DECODE: &[(u16, char)] = &[];\n");
        output.push_str("pub(crate) static BIG5_ENCODE: &[(char, u16)] = &[];\n\n");
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/index-big5.txt");
}

#[cfg(feature = "big5")]
fn generate_big5_tables(path: &Path, output: &mut String) {
    let content = std::fs::read_to_string(path).unwrap();
    let mut decode: BTreeMap<u16, char> = BTreeMap::new();

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        // Format: pointer\t0xCodepoint\tCharacter (Name)
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() < 2 {
            continue;
        }

        let pointer: u16 = match parts[0].trim().parse() {
            Ok(v) => v,
            Err(_) => continue,
        };

        let cp_str = parts[1].trim();
        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        if let Some(c) = char::from_u32(codepoint) {
            decode.insert(pointer, c);
        }
    }

    // Generate decode table (sorted by pointer for binary search)
    writeln!(output, "/// Big5 decode table: (pointer, char)").unwrap();
    writeln!(output, "pub(crate) static BIG5_DECODE: &[(u16, char)] = &[").unwrap();
    for (&pointer, &ch) in &decode {
        writeln!(output, "    ({}, '\\u{{{:04X}}}'),", pointer, ch as u32).unwrap();
    }
    writeln!(output, "];\n").unwrap();

    // Generate encode table (sorted by char for binary search)
    let mut encode: BTreeMap<char, u16> = BTreeMap::new();
    for (&pointer, &ch) in &decode {
        encode.entry(ch).or_insert(pointer);
    }

    writeln!(output, "/// Big5 encode table: (char, pointer)").unwrap();
    writeln!(output, "pub(crate) static BIG5_ENCODE: &[(char, u16)] = &[").unwrap();
    for (&ch, &pointer) in &encode {
        writeln!(output, "    ('\\u{{{:04X}}}', {}),", ch as u32, pointer).unwrap();
    }
    writeln!(output, "];\n").unwrap();
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn build_codepages() {
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest = Path::new(&out_dir).join("codepages.rs");

    let mappings_dir = Path::new("data/mappings");

    if !mappings_dir.exists() {
        std::fs::write(&dest, "// No codepage mappings found\n").unwrap();
        return;
    }

    let mut output = String::new();
    output.push_str("// Generated by build.rs - do not edit manually\n\n");
    output.push_str("use crate::encoding::Encoding;\n");
    output.push_str("use crate::error::EncodingError;\n\n");

    let mut codepage_names = Vec::new();
    let mut generated_names = std::collections::HashSet::new();

    // Scan only the subdirectories for enabled features
    #[cfg(feature = "codepages-iso8859")]
    scan_directory(
        &mappings_dir.join("iso8859"),
        "iso8859",
        &mut output,
        &mut codepage_names,
        &mut generated_names,
    );

    #[cfg(feature = "codepages-windows")]
    scan_directory(
        &mappings_dir.join("windows"),
        "windows",
        &mut output,
        &mut codepage_names,
        &mut generated_names,
    );

    #[cfg(feature = "codepages-dos")]
    scan_directory(
        &mappings_dir.join("dos"),
        "dos",
        &mut output,
        &mut codepage_names,
        &mut generated_names,
    );

    #[cfg(feature = "codepages-apple")]
    scan_directory(
        &mappings_dir.join("apple"),
        "apple",
        &mut output,
        &mut codepage_names,
        &mut generated_names,
    );

    #[cfg(feature = "codepages-misc")]
    scan_directory(
        &mappings_dir.join("misc"),
        "misc",
        &mut output,
        &mut codepage_names,
        &mut generated_names,
    );

    // Generate re-exports comment
    codepage_names.sort();
    if !codepage_names.is_empty() {
        output.push_str("// Available codepages:\n");
        for name in &codepage_names {
            writeln!(output, "// - {}", name).unwrap();
        }
    }

    std::fs::write(&dest, output).unwrap();
    println!("cargo:rerun-if-changed=data/mappings/");
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn scan_directory(
    dir: &Path,
    category: &str,
    output: &mut String,
    codepage_names: &mut Vec<String>,
    generated_names: &mut std::collections::HashSet<String>,
) {
    let entries = match std::fs::read_dir(dir) {
        Ok(e) => e,
        Err(_) => return,
    };

    for entry in entries {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };
        let path = entry.path();

        if path.is_dir() {
            scan_directory(&path, category, output, codepage_names, generated_names);
        } else if path
            .extension()
            .map(|e| e == "txt" || e == "TXT")
            .unwrap_or(false)
        {
            if let Some(codepage) = parse_and_generate(&path, category, output, generated_names) {
                codepage_names.push(codepage);
            }
        }
    }
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn parse_and_generate(
    path: &Path,
    category: &str,
    output: &mut String,
    generated_names: &mut std::collections::HashSet<String>,
) -> Option<String> {
    let content = std::fs::read_to_string(path).ok()?;
    let filename = path.file_stem()?.to_str()?;

    // Skip readme files
    if filename.to_lowercase() == "readme" {
        return None;
    }

    // Check for duplicates before doing anything
    let struct_name = derive_struct_name(filename);
    if generated_names.contains(&struct_name) {
        // Skip duplicate codepage (e.g., CP874 exists in both DOS and Windows)
        return None;
    }

    // Parse the mapping file
    // Format: 0xNN\t0xNNNN or 0xNNNN\t0xNNNN (for multi-byte)
    let mut single_byte_mappings: BTreeMap<u8, char> = BTreeMap::new();
    let mut multi_byte_mappings: BTreeMap<u32, char> = BTreeMap::new();
    let mut is_multi_byte = false;
    let mut max_bytes = 1usize;

    for line in content.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        let parts: Vec<&str> = line
            .split(|c| c == '\t' || c == ' ')
            .filter(|s| !s.is_empty())
            .collect();

        if parts.len() < 2 {
            continue;
        }

        // Parse byte value(s)
        let byte_str = parts[0].trim();
        let byte_val = if byte_str.starts_with("0x") || byte_str.starts_with("0X") {
            match u32::from_str_radix(&byte_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        // Parse unicode codepoint
        let cp_str = parts[1].trim();
        if cp_str.is_empty() || cp_str.starts_with('#') {
            continue;
        }

        let codepoint = if cp_str.starts_with("0x") || cp_str.starts_with("0X") {
            match u32::from_str_radix(&cp_str[2..], 16) {
                Ok(v) => v,
                Err(_) => continue,
            }
        } else {
            continue;
        };

        let c = match char::from_u32(codepoint) {
            Some(c) => c,
            None => continue,
        };

        if byte_val > 0xFF {
            is_multi_byte = true;
            let num_bytes = if byte_val > 0xFFFFFF {
                4
            } else if byte_val > 0xFFFF {
                3
            } else if byte_val > 0xFF {
                2
            } else {
                1
            };
            max_bytes = max_bytes.max(num_bytes);
            multi_byte_mappings.insert(byte_val, c);
        } else {
            single_byte_mappings.insert(byte_val as u8, c);
        }
    }

    // If we have multi-byte mappings, merge single-byte into multi-byte
    if is_multi_byte {
        for (&b, &c) in &single_byte_mappings {
            multi_byte_mappings.insert(b as u32, c);
        }
    }

    if single_byte_mappings.is_empty() && multi_byte_mappings.is_empty() {
        return None;
    }

    // Mark this name as generated
    generated_names.insert(struct_name.clone());

    if is_multi_byte {
        generate_multi_byte_encoding(
            &struct_name,
            filename,
            category,
            &multi_byte_mappings,
            max_bytes,
            output,
        )
    } else {
        generate_single_byte_encoding(
            &struct_name,
            filename,
            category,
            &single_byte_mappings,
            output,
        )
    }
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn generate_single_byte_encoding(
    struct_name: &str,
    filename: &str,
    category: &str,
    mappings: &BTreeMap<u8, char>,
    output: &mut String,
) -> Option<String> {
    let const_prefix = struct_name.to_uppercase();

    // Build decode table
    let mut decode_table = ['\u{FFFD}'; 256];
    for (&byte, &ch) in mappings {
        decode_table[byte as usize] = ch;
    }

    let has_undefined = decode_table.iter().any(|&c| c == '\u{FFFD}');

    // Generate struct
    writeln!(output, "/// {} encoding.", struct_name).unwrap();
    writeln!(
        output,
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]"
    )
    .unwrap();
    writeln!(output, "pub struct {};", struct_name).unwrap();
    writeln!(output).unwrap();

    // Generate decode table
    writeln!(output, "static {}_DECODE: [char; 256] = [", const_prefix).unwrap();
    for (i, chunk) in decode_table.chunks(8).enumerate() {
        write!(output, "    ").unwrap();
        for (j, &c) in chunk.iter().enumerate() {
            if j > 0 {
                write!(output, " ").unwrap();
            }
            write!(output, "'\\u{{{:04X}}}',", c as u32).unwrap();
        }
        writeln!(output, " // 0x{:02X}-0x{:02X}", i * 8, i * 8 + 7).unwrap();
    }
    writeln!(output, "];").unwrap();
    writeln!(output).unwrap();

    // Generate encode helper
    let ascii_identity = (0u8..128).all(|b| mappings.get(&b).copied() == Some(b as char));

    writeln!(output, "impl {} {{", struct_name).unwrap();
    writeln!(output, "    fn try_encode_byte(c: char) -> Option<u8> {{").unwrap();

    // Build reverse mapping (char -> byte), keeping first occurrence only
    let mut char_to_byte: BTreeMap<char, u8> = BTreeMap::new();
    for (&byte, &ch) in mappings {
        char_to_byte.entry(ch).or_insert(byte);
    }

    if ascii_identity {
        writeln!(output, "        let cp = c as u32;").unwrap();
        writeln!(output, "        if cp < 128 {{").unwrap();
        writeln!(output, "            return Some(cp as u8);").unwrap();
        writeln!(output, "        }}").unwrap();
        writeln!(output, "        match c {{").unwrap();
        for (&ch, &byte) in &char_to_byte {
            if byte >= 128 {
                writeln!(
                    output,
                    "            '\\u{{{:04X}}}' => Some(0x{:02X}),",
                    ch as u32, byte
                )
                .unwrap();
            }
        }
        writeln!(output, "            _ => None,").unwrap();
        writeln!(output, "        }}").unwrap();
    } else {
        writeln!(output, "        match c {{").unwrap();
        for (&ch, &byte) in &char_to_byte {
            writeln!(
                output,
                "            '\\u{{{:04X}}}' => Some(0x{:02X}),",
                ch as u32, byte
            )
            .unwrap();
        }
        writeln!(output, "            _ => None,").unwrap();
        writeln!(output, "        }}").unwrap();
    }

    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate Encoding impl
    let display_name = derive_display_name(filename, category);

    writeln!(output, "impl Encoding for {} {{", struct_name).unwrap();
    writeln!(
        output,
        "    const NAME: &'static str = \"{}\";",
        display_name
    )
    .unwrap();
    writeln!(output, "    const IS_FIXED_WIDTH: bool = true;").unwrap();
    writeln!(output, "    const BYTES_PER_CHAR: Option<usize> = Some(1);").unwrap();
    writeln!(output, "    const MAX_CHAR_LEN: usize = 1;").unwrap();
    writeln!(output).unwrap();

    if has_undefined {
        writeln!(
            output,
            "    fn validate(bytes: &[u8]) -> Result<(), EncodingError> {{"
        )
        .unwrap();
        writeln!(
            output,
            "        for (i, &byte) in bytes.iter().enumerate() {{"
        )
        .unwrap();
        writeln!(
            output,
            "            if {}_DECODE[byte as usize] == '\\u{{FFFD}}' {{",
            const_prefix
        )
        .unwrap();
        writeln!(
            output,
            "                return Err(EncodingError::new(i, Some(1)));"
        )
        .unwrap();
        writeln!(output, "            }}").unwrap();
        writeln!(output, "        }}").unwrap();
        writeln!(output, "        Ok(())").unwrap();
        writeln!(output, "    }}").unwrap();
    } else {
        writeln!(
            output,
            "    fn validate(_bytes: &[u8]) -> Result<(), EncodingError> {{"
        )
        .unwrap();
        writeln!(output, "        Ok(())").unwrap();
        writeln!(output, "    }}").unwrap();
    }
    writeln!(output).unwrap();

    writeln!(
        output,
        "    fn decode_char_at(bytes: &[u8], offset: usize) -> Option<(char, usize)> {{"
    )
    .unwrap();
    writeln!(output, "        let byte = *bytes.get(offset)?;").unwrap();
    writeln!(
        output,
        "        let c = {}_DECODE[byte as usize];",
        const_prefix
    )
    .unwrap();
    if has_undefined {
        writeln!(output, "        if c == '\\u{{FFFD}}' {{ return None; }}").unwrap();
    }
    writeln!(output, "        Some((c, offset + 1))").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "    fn encoded_len(_c: char) -> usize {{ 1 }}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "    fn encode_char(c: char, buf: &mut [u8]) -> usize {{"
    )
    .unwrap();
    writeln!(output, "        buf[0] = Self::try_encode_byte(c)").unwrap();
    writeln!(
        output,
        "            .expect(\"character cannot be encoded in {}\");",
        display_name
    )
    .unwrap();
    writeln!(output, "        1").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "    fn try_encode_char(c: char, buf: &mut [u8]) -> Option<usize> {{"
    )
    .unwrap();
    writeln!(output, "        buf[0] = Self::try_encode_byte(c)?;").unwrap();
    writeln!(output, "        Some(1)").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    writeln!(output, "    fn can_encode(c: char) -> bool {{").unwrap();
    writeln!(output, "        Self::try_encode_byte(c).is_some()").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "    fn is_char_boundary(bytes: &[u8], index: usize) -> bool {{"
    )
    .unwrap();
    writeln!(output, "        index <= bytes.len()").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    writeln!(
        output,
        "    fn decode_char_before(bytes: &[u8], offset: usize) -> Option<(char, usize)> {{"
    )
    .unwrap();
    writeln!(
        output,
        "        if offset == 0 || offset > bytes.len() {{ return None; }}"
    )
    .unwrap();
    writeln!(output, "        let byte = bytes[offset - 1];").unwrap();
    writeln!(
        output,
        "        let c = {}_DECODE[byte as usize];",
        const_prefix
    )
    .unwrap();
    if has_undefined {
        writeln!(output, "        if c == '\\u{{FFFD}}' {{ return None; }}").unwrap();
    }
    writeln!(output, "        Some((c, offset - 1))").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate LimitedEncoding impl
    writeln!(
        output,
        "impl crate::encoding::LimitedEncoding for {} {{}}",
        struct_name
    )
    .unwrap();
    writeln!(output).unwrap();

    // Generate registry registration
    let aliases = derive_registry_aliases(filename, category, struct_name);
    writeln!(output, "#[cfg(feature = \"registry\")]").unwrap();
    writeln!(output, "inventory::submit! {{").unwrap();
    writeln!(output, "    crate::registry::EncodingEntry {{").unwrap();
    writeln!(output, "        name: \"{}\",", display_name).unwrap();
    let aliases_str: Vec<_> = aliases.iter().map(|a| format!("\"{}\"", a)).collect();
    writeln!(output, "        aliases: &[{}],", aliases_str.join(", ")).unwrap();
    writeln!(output, "        is_unicode: false,").unwrap();
    writeln!(output, "        decode: |bytes| {{").unwrap();
    writeln!(output, "            {}::validate(bytes)?;", struct_name).unwrap();
    writeln!(output, "            let mut chars = Vec::new();").unwrap();
    writeln!(output, "            for &b in bytes {{").unwrap();
    writeln!(
        output,
        "                let c = {}_DECODE[b as usize];",
        const_prefix
    )
    .unwrap();
    writeln!(output, "                chars.push(c);").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "            Ok(chars)").unwrap();
    writeln!(output, "        }},").unwrap();
    writeln!(output, "        try_encode_char: |c| {{").unwrap();
    writeln!(
        output,
        "            {}::try_encode_byte(c).map(|b| vec![b])",
        struct_name
    )
    .unwrap();
    writeln!(output, "        }},").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    Some(struct_name.to_string())
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn generate_multi_byte_encoding(
    struct_name: &str,
    filename: &str,
    category: &str,
    mappings: &BTreeMap<u32, char>,
    max_bytes: usize,
    output: &mut String,
) -> Option<String> {
    let const_prefix = struct_name.to_uppercase();
    let display_name = derive_display_name(filename, category);

    // Separate single-byte and multi-byte mappings
    let mut single_byte: BTreeMap<u8, char> = BTreeMap::new();
    let mut double_byte: BTreeMap<u16, char> = BTreeMap::new();

    for (&bytes, &ch) in mappings {
        if bytes <= 0xFF {
            single_byte.insert(bytes as u8, ch);
        } else if bytes <= 0xFFFF {
            double_byte.insert(bytes as u16, ch);
        }
        // Ignore 3+ byte sequences for now (rare)
    }

    // Determine lead byte ranges (bytes that start a 2-byte sequence)
    let mut lead_bytes = std::collections::BTreeSet::new();
    for &key in double_byte.keys() {
        lead_bytes.insert((key >> 8) as u8);
    }

    // Generate struct
    writeln!(output, "/// {} encoding (multi-byte).", struct_name).unwrap();
    writeln!(
        output,
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]"
    )
    .unwrap();
    writeln!(output, "pub struct {};", struct_name).unwrap();
    writeln!(output).unwrap();

    // Generate single-byte decode table
    let mut decode_1byte = ['\u{FFFD}'; 256];
    for (&b, &c) in &single_byte {
        decode_1byte[b as usize] = c;
    }
    // Mark lead bytes as needing second byte (use a sentinel)
    for &lb in &lead_bytes {
        if decode_1byte[lb as usize] == '\u{FFFD}' {
            // Keep as FFFD, we'll check lead bytes separately
        }
    }

    writeln!(
        output,
        "static {}_DECODE_1BYTE: [char; 256] = [",
        const_prefix
    )
    .unwrap();
    for (i, chunk) in decode_1byte.chunks(8).enumerate() {
        write!(output, "    ").unwrap();
        for (j, &c) in chunk.iter().enumerate() {
            if j > 0 {
                write!(output, " ").unwrap();
            }
            write!(output, "'\\u{{{:04X}}}',", c as u32).unwrap();
        }
        writeln!(output, " // 0x{:02X}-0x{:02X}", i * 8, i * 8 + 7).unwrap();
    }
    writeln!(output, "];").unwrap();
    writeln!(output).unwrap();

    // Generate lead byte check function
    writeln!(output, "impl {} {{", struct_name).unwrap();
    writeln!(output, "    #[inline]").unwrap();
    writeln!(output, "    fn is_lead_byte(b: u8) -> bool {{").unwrap();
    if lead_bytes.is_empty() {
        writeln!(output, "        false").unwrap();
    } else {
        // Generate range checks
        let ranges = compress_to_ranges(&lead_bytes);
        let mut conditions = Vec::new();
        for (start, end) in ranges {
            if start == end {
                conditions.push(format!("b == 0x{:02X}", start));
            } else {
                conditions.push(format!("(0x{:02X}..=0x{:02X}).contains(&b)", start, end));
            }
        }
        writeln!(output, "        {}", conditions.join(" || ")).unwrap();
    }
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // Generate 2-byte decode function
    writeln!(
        output,
        "    fn decode_2byte(b1: u8, b2: u8) -> Option<char> {{"
    )
    .unwrap();
    writeln!(
        output,
        "        let key = ((b1 as u16) << 8) | (b2 as u16);"
    )
    .unwrap();
    writeln!(output, "        match key {{").unwrap();
    for (&key, &ch) in &double_byte {
        writeln!(
            output,
            "            0x{:04X} => Some('\\u{{{:04X}}}'),",
            key, ch as u32
        )
        .unwrap();
    }
    writeln!(output, "            _ => None,").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // Generate encode helper - build reverse mapping to avoid duplicate character matches
    // Format: char -> (b1, Option<b2>)
    let mut char_to_bytes: BTreeMap<char, (u8, Option<u8>)> = BTreeMap::new();
    // Single-byte first (prefer single-byte encoding if available)
    for (&b, &ch) in &single_byte {
        char_to_bytes.entry(ch).or_insert((b, None));
    }
    // Then double-byte (only if not already mapped)
    for (&key, &ch) in &double_byte {
        let b1 = (key >> 8) as u8;
        let b2 = (key & 0xFF) as u8;
        char_to_bytes.entry(ch).or_insert((b1, Some(b2)));
    }

    writeln!(
        output,
        "    fn try_encode_bytes(c: char) -> Option<(u8, Option<u8>)> {{"
    )
    .unwrap();
    writeln!(output, "        match c {{").unwrap();
    for (&ch, &(b1, b2_opt)) in &char_to_bytes {
        match b2_opt {
            Some(b2) => writeln!(
                output,
                "            '\\u{{{:04X}}}' => Some((0x{:02X}, Some(0x{:02X}))),",
                ch as u32, b1, b2
            )
            .unwrap(),
            None => writeln!(
                output,
                "            '\\u{{{:04X}}}' => Some((0x{:02X}, None)),",
                ch as u32, b1
            )
            .unwrap(),
        }
    }
    writeln!(output, "            _ => None,").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate Encoding impl
    writeln!(output, "impl Encoding for {} {{", struct_name).unwrap();
    writeln!(
        output,
        "    const NAME: &'static str = \"{}\";",
        display_name
    )
    .unwrap();
    writeln!(output, "    const IS_FIXED_WIDTH: bool = false;").unwrap();
    writeln!(output, "    const BYTES_PER_CHAR: Option<usize> = None;").unwrap();
    writeln!(output, "    const MAX_CHAR_LEN: usize = {};", max_bytes).unwrap();
    writeln!(output).unwrap();

    // validate
    writeln!(
        output,
        "    fn validate(bytes: &[u8]) -> Result<(), EncodingError> {{"
    )
    .unwrap();
    writeln!(output, "        let mut i = 0;").unwrap();
    writeln!(output, "        while i < bytes.len() {{").unwrap();
    writeln!(output, "            let b1 = bytes[i];").unwrap();
    writeln!(output, "            if Self::is_lead_byte(b1) {{").unwrap();
    writeln!(output, "                if i + 1 >= bytes.len() {{").unwrap();
    writeln!(
        output,
        "                    return Err(EncodingError::new(i, Some(1)));"
    )
    .unwrap();
    writeln!(output, "                }}").unwrap();
    writeln!(output, "                let b2 = bytes[i + 1];").unwrap();
    writeln!(
        output,
        "                if Self::decode_2byte(b1, b2).is_none() {{"
    )
    .unwrap();
    writeln!(
        output,
        "                    return Err(EncodingError::new(i, Some(2)));"
    )
    .unwrap();
    writeln!(output, "                }}").unwrap();
    writeln!(output, "                i += 2;").unwrap();
    writeln!(output, "            }} else {{").unwrap();
    writeln!(
        output,
        "                if {}_DECODE_1BYTE[b1 as usize] == '\\u{{FFFD}}' {{",
        const_prefix
    )
    .unwrap();
    writeln!(
        output,
        "                    return Err(EncodingError::new(i, Some(1)));"
    )
    .unwrap();
    writeln!(output, "                }}").unwrap();
    writeln!(output, "                i += 1;").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        Ok(())").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // decode_char_at
    writeln!(
        output,
        "    fn decode_char_at(bytes: &[u8], offset: usize) -> Option<(char, usize)> {{"
    )
    .unwrap();
    writeln!(output, "        let b1 = *bytes.get(offset)?;").unwrap();
    writeln!(output, "        if Self::is_lead_byte(b1) {{").unwrap();
    writeln!(output, "            let b2 = *bytes.get(offset + 1)?;").unwrap();
    writeln!(output, "            let c = Self::decode_2byte(b1, b2)?;").unwrap();
    writeln!(output, "            Some((c, offset + 2))").unwrap();
    writeln!(output, "        }} else {{").unwrap();
    writeln!(
        output,
        "            let c = {}_DECODE_1BYTE[b1 as usize];",
        const_prefix
    )
    .unwrap();
    writeln!(
        output,
        "            if c == '\\u{{FFFD}}' {{ return None; }}"
    )
    .unwrap();
    writeln!(output, "            Some((c, offset + 1))").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // encoded_len
    writeln!(output, "    fn encoded_len(c: char) -> usize {{").unwrap();
    writeln!(output, "        match Self::try_encode_bytes(c) {{").unwrap();
    writeln!(output, "            Some((_, Some(_))) => 2,").unwrap();
    writeln!(output, "            Some((_, None)) => 1,").unwrap();
    writeln!(
        output,
        "            None => 1, // Will panic in encode_char"
    )
    .unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // encode_char
    writeln!(
        output,
        "    fn encode_char(c: char, buf: &mut [u8]) -> usize {{"
    )
    .unwrap();
    writeln!(output, "        match Self::try_encode_bytes(c) {{").unwrap();
    writeln!(output, "            Some((b1, Some(b2))) => {{").unwrap();
    writeln!(output, "                buf[0] = b1;").unwrap();
    writeln!(output, "                buf[1] = b2;").unwrap();
    writeln!(output, "                2").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "            Some((b1, None)) => {{").unwrap();
    writeln!(output, "                buf[0] = b1;").unwrap();
    writeln!(output, "                1").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(
        output,
        "            None => panic!(\"character cannot be encoded in {}\"),",
        display_name
    )
    .unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // try_encode_char
    writeln!(
        output,
        "    fn try_encode_char(c: char, buf: &mut [u8]) -> Option<usize> {{"
    )
    .unwrap();
    writeln!(output, "        match Self::try_encode_bytes(c)? {{").unwrap();
    writeln!(output, "            (b1, Some(b2)) => {{").unwrap();
    writeln!(output, "                buf[0] = b1;").unwrap();
    writeln!(output, "                buf[1] = b2;").unwrap();
    writeln!(output, "                Some(2)").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "            (b1, None) => {{").unwrap();
    writeln!(output, "                buf[0] = b1;").unwrap();
    writeln!(output, "                Some(1)").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // can_encode
    writeln!(output, "    fn can_encode(c: char) -> bool {{").unwrap();
    writeln!(output, "        Self::try_encode_bytes(c).is_some()").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // is_char_boundary
    writeln!(
        output,
        "    fn is_char_boundary(bytes: &[u8], index: usize) -> bool {{"
    )
    .unwrap();
    writeln!(output, "        if index == 0 || index == bytes.len() {{").unwrap();
    writeln!(output, "            return true;").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        if index > bytes.len() {{").unwrap();
    writeln!(output, "            return false;").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        // Check if previous byte is a lead byte").unwrap();
    writeln!(output, "        let prev = bytes[index - 1];").unwrap();
    writeln!(output, "        !Self::is_lead_byte(prev)").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output).unwrap();

    // decode_char_before
    writeln!(
        output,
        "    fn decode_char_before(bytes: &[u8], offset: usize) -> Option<(char, usize)> {{"
    )
    .unwrap();
    writeln!(output, "        if offset == 0 || offset > bytes.len() {{").unwrap();
    writeln!(output, "            return None;").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        // Try 2-byte first if possible").unwrap();
    writeln!(output, "        if offset >= 2 {{").unwrap();
    writeln!(output, "            let b1 = bytes[offset - 2];").unwrap();
    writeln!(output, "            let b2 = bytes[offset - 1];").unwrap();
    writeln!(output, "            if Self::is_lead_byte(b1) {{").unwrap();
    writeln!(
        output,
        "                if let Some(c) = Self::decode_2byte(b1, b2) {{"
    )
    .unwrap();
    writeln!(output, "                    return Some((c, offset - 2));").unwrap();
    writeln!(output, "                }}").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        // Try 1-byte").unwrap();
    writeln!(output, "        let b = bytes[offset - 1];").unwrap();
    writeln!(
        output,
        "        let c = {}_DECODE_1BYTE[b as usize];",
        const_prefix
    )
    .unwrap();
    writeln!(output, "        if c == '\\u{{FFFD}}' {{").unwrap();
    writeln!(output, "            return None;").unwrap();
    writeln!(output, "        }}").unwrap();
    writeln!(output, "        Some((c, offset - 1))").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    // Generate LimitedEncoding impl
    writeln!(
        output,
        "impl crate::encoding::LimitedEncoding for {} {{}}",
        struct_name
    )
    .unwrap();
    writeln!(output).unwrap();

    // Generate registry registration
    let aliases = derive_registry_aliases(filename, category, struct_name);
    writeln!(output, "#[cfg(feature = \"registry\")]").unwrap();
    writeln!(output, "inventory::submit! {{").unwrap();
    writeln!(output, "    crate::registry::EncodingEntry {{").unwrap();
    writeln!(output, "        name: \"{}\",", display_name).unwrap();
    let aliases_str: Vec<_> = aliases.iter().map(|a| format!("\"{}\"", a)).collect();
    writeln!(output, "        aliases: &[{}],", aliases_str.join(", ")).unwrap();
    writeln!(output, "        is_unicode: false,").unwrap();
    writeln!(output, "        decode: |bytes| {{").unwrap();
    writeln!(output, "            {}::validate(bytes)?;", struct_name).unwrap();
    writeln!(output, "            let mut chars = Vec::new();").unwrap();
    writeln!(output, "            let mut offset = 0;").unwrap();
    writeln!(
        output,
        "            while let Some((c, next)) = {}::decode_char_at(bytes, offset) {{",
        struct_name
    )
    .unwrap();
    writeln!(output, "                chars.push(c);").unwrap();
    writeln!(output, "                offset = next;").unwrap();
    writeln!(output, "            }}").unwrap();
    writeln!(output, "            Ok(chars)").unwrap();
    writeln!(output, "        }},").unwrap();
    writeln!(output, "        try_encode_char: |c| {{").unwrap();
    writeln!(
        output,
        "            {}::try_encode_bytes(c).map(|(b1, b2)| {{",
        struct_name
    )
    .unwrap();
    writeln!(output, "                match b2 {{").unwrap();
    writeln!(output, "                    Some(b2) => vec![b1, b2],").unwrap();
    writeln!(output, "                    None => vec![b1],").unwrap();
    writeln!(output, "                }}").unwrap();
    writeln!(output, "            }})").unwrap();
    writeln!(output, "        }},").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}").unwrap();
    writeln!(output).unwrap();

    Some(struct_name.to_string())
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn compress_to_ranges(bytes: &std::collections::BTreeSet<u8>) -> Vec<(u8, u8)> {
    let mut ranges = Vec::new();
    let mut iter = bytes.iter().copied();

    if let Some(first) = iter.next() {
        let mut start = first;
        let mut end = first;

        for b in iter {
            if b == end + 1 {
                end = b;
            } else {
                ranges.push((start, end));
                start = b;
                end = b;
            }
        }
        ranges.push((start, end));
    }

    ranges
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn derive_struct_name(filename: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;

    // Handle filenames starting with digits by adding prefix
    let first_char = filename.chars().next();
    let needs_prefix = first_char.map(|c| c.is_ascii_digit()).unwrap_or(false);

    if needs_prefix {
        // Detect what kind of encoding this is based on filename patterns
        if filename.contains("8859") {
            result.push_str("Iso");
        } else {
            result.push_str("Cp");
        }
    }

    for c in filename.chars() {
        if c == '-' || c == '_' {
            // Keep underscore only if transitioning from digit to something else
            if !result.is_empty()
                && result
                    .chars()
                    .last()
                    .map(|c| c.is_ascii_digit())
                    .unwrap_or(false)
            {
                result.push('_');
            }
            capitalize_next = true;
        } else if c.is_ascii_alphanumeric() {
            if capitalize_next {
                result.push(c.to_ascii_uppercase());
                capitalize_next = false;
            } else {
                result.push(c.to_ascii_lowercase());
            }
        }
    }

    // Special handling for KOI8 to get Koi8R instead of Koi8_R
    if result.starts_with("Koi8_") {
        result = result.replace("Koi8_", "Koi8");
    }

    result
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn derive_display_name(filename: &str, category: &str) -> String {
    match category {
        "iso8859" => format!("ISO-{}", filename.replace('_', "-")),
        "windows" if filename.starts_with("CP") => {
            format!("Windows-{}", &filename[2..])
        }
        "apple" => {
            // Convert ROMAN -> MacRoman, CROATIAN -> MacCroatian
            let mut result = String::from("Mac");
            let mut first = true;
            for c in filename.chars() {
                if first {
                    result.push(c.to_ascii_uppercase());
                    first = false;
                } else {
                    result.push(c.to_ascii_lowercase());
                }
            }
            result
        }
        _ => filename.replace('_', "-"),
    }
}

#[cfg(any(
    feature = "codepages-iso8859",
    feature = "codepages-windows",
    feature = "codepages-dos",
    feature = "codepages-apple",
    feature = "codepages-misc",
))]
fn derive_registry_aliases(filename: &str, category: &str, struct_name: &str) -> Vec<String> {
    let display_name = derive_display_name(filename, category);
    let mut aliases = vec![struct_name.to_string()];

    match category {
        "iso8859" => {
            // ISO-8859-N patterns
            let num = &filename[5..]; // Skip "8859-"
            aliases.push(format!("ISO-8859-{}", num));
            aliases.push(format!("iso-8859-{}", num));
            aliases.push(format!("ISO8859-{}", num));
            aliases.push(format!("iso8859-{}", num));
            aliases.push(format!("ISO_8859-{}", num));
            aliases.push(format!("iso_8859-{}", num));
            aliases.push(format!("8859-{}", num));
            // Special aliases for common codepages
            match num {
                "1" => {
                    aliases.push("latin1".to_string());
                    aliases.push("latin-1".to_string());
                    aliases.push("LATIN1".to_string());
                }
                "2" => aliases.push("latin2".to_string()),
                "15" => aliases.push("latin9".to_string()),
                _ => {}
            }
        }
        "windows" if filename.starts_with("CP") => {
            let num = &filename[2..];
            aliases.push(format!("CP{}", num));
            aliases.push(format!("cp{}", num));
            aliases.push(format!("windows-{}", num));
            aliases.push(format!("WINDOWS-{}", num));
        }
        "dos" if filename.starts_with("CP") => {
            let num = &filename[2..];
            aliases.push(format!("cp{}", num));
            aliases.push(format!("IBM{}", num));
            aliases.push(format!("ibm{}", num));
        }
        "apple" => {
            // MacRoman, x-mac-roman, etc.
            let lower = display_name.to_lowercase();
            aliases.push(lower.clone());
            aliases.push(format!("x-mac-{}", &lower[3..])); // x-mac-roman
        }
        "misc" => {
            // KOI8, EBCDIC, etc.
            if filename.starts_with("KOI8") {
                aliases.push(filename.to_lowercase());
                aliases.push(filename.replace('-', "_"));
                aliases.push(filename.replace('-', "_").to_lowercase());
            } else if filename.starts_with("CP") {
                // EBCDIC codepages
                let num = &filename[2..];
                aliases.push(format!("cp{}", num));
                aliases.push(format!("IBM{}", num));
                aliases.push(format!("ibm{}", num));
            }
        }
        _ => {}
    }

    aliases
}
